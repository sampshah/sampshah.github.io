---
layout: post
title: Handy Snippets | Tech
comments: true
---

## Python general

- Useful for strings
```python
x = ord('A') # ASCII value from character
y = chr(x)   # Character from ASCII value
a = 'abc'.isalpha()   # returns boolean if it is only alphabet
b = 'abc12'.isalnum() # returns boolean if it is only alpha and nums
c = '123'.isdigit()   # returns boolean if it is only digits
letters.sort(key = lambda x: x.split()[1]) # sort lexicographically
```
- Error catching  
```python
assert <expression> , "<message>"

# OR

if not <expression>:
    raise AssertionError("<message>")

# OR use try except

try:
  print("Hello")
except:
  print("Something went wrong") # if error in try
else:
  print("Nothing went wrong")  # if no error in try

# try except with finally

try:
  print(x)
except:
  print("Something went wrong")
finally:
  print("The 'try except' is finished")  # finally block is executed regardless of errors or no errors in try
```

## Cpp general

- Char to ascii and vice versa
```cpp
int x = int('c');  // ascii value of characters
char c = (char)x;  // character from ascii
```
- [Sizes of Classes](https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/)
- [Templates](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl) (Specifically for syntax and definition in cpp file FAQ)
- When having a member of the Class type, remember [this](https://www.geeksforgeeks.org/can-a-c-class-have-an-object-of-self-type/)
- Using [const](https://stackoverflow.com/questions/15999123/const-before-parameter-vs-const-after-function-name-c):  
```cpp
struct X
{
    void foo() const // <== The implicit "this" pointer is const-qualified!
    {
        _x = 42; // ERROR! The "this" pointer is implicitly const
        _y = 42; // OK (_y is mutable)
    }

    void bar(X& obj) const // <== The implicit "this" pointer is const-qualified!
    {
        obj._x = 42; // OK! obj is a reference to non-const
        _x = 42; // ERROR! The "this" pointer is implicitly const
    }

    void bar(X const& obj) // <== The implicit "this" pointer is NOT const-qualified!
    {
        obj._x = 42; // ERROR! obj is a reference to const
        obj._y = 42; // OK! obj is a reference to const, but _y is mutable
        _x = 42; // OK! The "this" pointer is implicitly non-const
    }

    int _x;
    mutable int _y;
};
```


- [Local classes](https://www.geeksforgeeks.org/local-class-in-c/) and [Nested Classes](https://www.geeksforgeeks.org/nested-classes-in-c/)

- Brace Initializers:   

https://www.modernescpp.com/index.php/initialization ,  
https://www.youtube.com/watch?v=SmriQ5zXeAk ,  
https://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives  

- Threads: 

http://jakascorner.com/blog/page2/



## Linux and Git Commands  

- Sometimes you may want to keep a watch on something:  
```
watch -n <number_of_seconds> <command>
```

- Reduce brightness below minimum  (replace 2070)
```
cat /sys/class/backlight/intel_backlight/brightness
sudo su -c "echo 2070 >/sys/class/backlight/intel_backlight/brightness"
```

- Mute an application :   
```
pacmd list-sink-inputs
pacmd set-sink-input-mute <index> true(/false)
```

- Setting upstream: sometimes you may want a local branch to track another remote branch
```
# check which branch tracks what
git branch -vv
# set upstream
git branch -u <remote>/<branch>
# or If you just wish to push once to another remote branch 
git push <remote> <local_branch>:<remote_name>
```

- sshfs: One of the most handy commands when working on remote server  
```
sshfs USER@IP:/$PATH $LOCAL_PATH
```

- scp: copy recursively all files and folders  
```
scp -rp sourcedirectory user@dest:/path
# -r for recursive and -p to preserve modification times and modes
```

- Screen: another handy function when working remotely, to prevent creating multiple sessions locally
```
# make screen
screen -S myscreen 
# list all 
screen -ls
# attach to a session
screen -r <name>
# detach
screen -d <name>
# detach
C-a d
# kill
C-a k
```

## Miscellaneous  

- Auto reload modules in Jupyter  
```
# add to beginning of notebook
%load_ext autoreload
%autoreload 2
```

- Run Jupyter Nodebook on remote server via ssh  

```
# open it on remote
sasha@remote $ jupyter notebook --no-browser --port=8887

# Tunnel through ssh on local
ssh -N -L localhost:8888:localhost:8887 sasha@remote
```

- Download all google search images with filters: Fatkun batch extension
```
https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf?hl=en
```

## Sorting Algorithms  

- Bubble sort  

C++

 ```cpp
void bubble_sort( int A[ ], int n ) {
    int temp;
    for(int k = 0; k< n-1; k++) {
        // (n-k-1) is for ignoring comparisons of elements which have already been compared in earlier iterations

        for(int i = 0; i < n-k-1; i++) {
            if(A[ i ] > A[ i+1] ) {
                // here swapping of positions is being done.
                temp = A[ i ];
                A[ i ] = A[ i+1 ];
                A[ i + 1] = temp;
            }
        }
    }
}
 ```  

Python: 

 ```python
def bubbleSort(arr): 
    n = len(arr) 
  
    # Traverse through all array elements 
    for i in range(n-1): 
    # range(n) also work but outer loop will repeat one time more than needed. 
  
        # Last i elements are already in place 
        for j in range(0, n-i-1): 
  
            # traverse the array from 0 to n-i-1 
            # Swap if the element found is greater 
            # than the next element 
            if arr[j] > arr[j+1] : 
                arr[j], arr[j+1] = arr[j+1], arr[j] 

 ```




- Insertion sort  

C++

```cpp
void insertion_sort(int A[], int n) {
    for (int i = 0; i < n; i++) {
        /*storing current element whose left side is checked for its 
                 correct position .*/

        int temp = A[i];
        int j = i;

        /* check whether the adjacent element in left side is greater or
             less than the current element. */

        while (j > 0 && temp < A[j - 1]) {

            // moving the left side element to one position forward.
            A[j] = A[j - 1];
            j = j - 1;

        }
        // moving current element to its  correct position.
        A[j] = temp;
    }
}

```
Python

```python
def insertionSort(arr): 
  
    # Traverse through 1 to len(arr) 
    for i in range(1, len(arr)): 
  
        key = arr[i] 
  
        # Move elements of arr[0..i-1], that are 
        # greater than key, to one position ahead 
        # of their current position 
        j = i-1
        while j >=0 and key < arr[j] : 
                arr[j+1] = arr[j] 
                j -= 1
        arr[j+1] = key 
```

- Merge Sort

Cpp   

```cpp
void merge(int A[], int start, int mid, int end) {
    //stores the starting position of both parts in temporary variables.
    int p = start, q = mid + 1;

    int Arr[end - start + 1], k = 0;

    for (int i = start; i <= end; i++) {
        if (p > mid) //checks if first part comes to an end or not .
            Arr[k++] = A[q++];

        else if (q > end) //checks if second part comes to an end or not
            Arr[k++] = A[p++];

        else if (A[p] < A[q]) //checks which part has smaller element.
            Arr[k++] = A[p++];

        else
            Arr[k++] = A[q++];
    }
    for (int p = 0; p < k; p++) {
        /* Now the real array has elements in sorted manner including both 
             parts.*/
        A[start++] = Arr[p];
    }
}

void merge_sort(int A[], int start, int end) {
    if (start < end) {
        int mid = (start + end) / 2; // defines the current array in 2 parts .
        merge_sort(A, start, mid); // sort the 1st part of array .
        merge_sort(A, mid + 1, end); // sort the 2nd part of array.

        // merge the both parts by comparing elements of both the parts.
        merge(A, start, mid, end);
    }
}

```

Python  

```python
def mergeSort(arr): 
    if len(arr) >1: 
        mid = len(arr)//2 # Finding the mid of the array 
        L = arr[:mid] # Dividing the array elements  
        R = arr[mid:] # into 2 halves 
  
        mergeSort(L) # Sorting the first half 
        mergeSort(R) # Sorting the second half 
  
        i = j = k = 0
          
        # Copy data to temp arrays L[] and R[] 
        while i < len(L) and j < len(R): 
            if L[i] < R[j]: 
                arr[k] = L[i] 
                i+= 1
            else: 
                arr[k] = R[j] 
                j+= 1
            k+= 1
          
        # Checking if any element was left 
        while i < len(L): 
            arr[k] = L[i] 
            i+= 1
            k+= 1
          
        while j < len(R): 
            arr[k] = R[j] 
            j+= 1
            k+= 1
```

- Quick Sort  

C++  

```cpp
int partition(int A[], int start, int end) {
    int i = start + 1;
    int piv = A[start]; //make the first element as pivot element.
    for (int j = start + 1; j <= end; j++) {
        /*rearrange the array by putting elements which are less than pivot
           on one side and which are greater that on other. */

        if (A[j] < piv) {
            swap(A[i], A[j]);
            i += 1;
        }
    }
    swap(A[start], A[i - 1]); //put the pivot element in its proper place.
    return i - 1; //return the position of the pivot
}
void quick_sort ( int A[ ] ,int start , int end ) {
   if( start < end ) {
        //stores the position of pivot element
         int piv_pos = partition (A,start , end ) ;     
         quick_sort (A,start , piv_pos -1);    //sorts the left side of pivot.
         quick_sort ( A,piv_pos +1 , end) ; //sorts the right side of pivot.
   }
}

```

Python 

```python
def partition(arr,low,high): 
    i = ( low-1 )         # index of smaller element 
    pivot = arr[high]     # pivot 
  
    for j in range(low , high): 
  
        # If current element is smaller than or 
        # equal to pivot 
        if   arr[j] <= pivot: 
          
            # increment index of smaller element 
            i = i+1 
            arr[i],arr[j] = arr[j],arr[i] 
  
    arr[i+1],arr[high] = arr[high],arr[i+1] 
    return ( i+1 ) 
  
# The main function that implements QuickSort 
# arr[] --> Array to be sorted, 
# low  --> Starting index, 
# high  --> Ending index 
  
# Function to do Quick sort 
def quickSort(arr,low,high): 
    if low < high: 
  
        # pi is partitioning index, arr[p] is now 
        # at right place 
        pi = partition(arr,low,high) 
  
        # Separately sort elements before 
        # partition and after partition 
        quickSort(arr, low, pi-1) 
        quickSort(arr, pi+1, high) 
```


References:  
- https://rikenshah.github.io/articles/codemonk-part1/
- geeksforgeeks.org
- https://arnavdhamija.com/computer-tips/


... to be continued
